
/DECLARE/
QUEUE SRC, LIEN1, LIEN2, LIEN3;
INTEGER I, C, ERL = 70, NbSimu = 20;
REAL RHO, LAMBDA, DUREE, TOT, TOTFAIL, App1OK, App1Bloc, App2OK, App2Bloc, App3OK, App3Bloc, MU = 1./180;
CUSTOMER REAL DUREE;
REF CUSTOMER CUST;
FILE courbe;


& Station emettrice des appels de duree exponentielle
/STATION/
NAME = SRC;
TYPE = SOURCE;
SERVICE = BEGIN
    EXP(1./LAMBDA);
    TOT := TOT +1;
    & Verification que le LIEN1 ne soit pas surcharge pour envoyer sur le 1er chemin
    IF (CUSTNB(LIEN1) < C) THEN
        BEGIN
            DUREE := EXP(1./MU);
            TRANSIT(LIEN1);
        END
    & Sinon on envoit sur le chemin de debordement
    ELSE
        BEGIN
            IF (CUSTNB(LIEN2) < C) AND (CUSTNB(LIEN2) < C) THEN
                BEGIN
                    DUREE := EXP(1./MU);
                    CUST := NEW (CUSTOMER);
                    CUST.DUREE := DUREE;
                    TRANSIT(CUST,LIEN2);
                    TRANSIT(LIEN3);
                END
            ELSE
                BEGIN
                    TOTFAIL := TOTFAIL + 1;
                END;
        END;
END;
TRANSIT = OUT;


& Station receptrice simulant le premier lien (donc 1er chemin)
/STATION/
NAME = LIEN1;
TYPE = MULTIPLE(C);
& Si l'appel peut etre decroche, alors on compte le nombre d'appel recu
SERVICE =
BEGIN
    EXP(1./MU);
    App1OK := App1OK +1;
END;
CAPACITY = C;
& En cas de rejet, on compte le nombre d'appel bloque
REJECT =
BEGIN
    App1Bloc := App1Bloc + 1;
    TRANSIT(OUT);
END;
TRANSIT = OUT;


& Station receptrice simulant le second lien (1ere partie du 2nd chemin)
/STATION/
NAME=LIEN2;
TYPE= MULTIPLE(C);
SERVICE =
BEGIN
    EXP(1./MU);
    App2OK := App2OK +1;
END;
CAPACITY = C;
& En cas de rejet, on compte le nombre d'appel bloque
REJECT =
BEGIN
    App2Bloc := App2Bloc + 1;
    TRANSIT(OUT);
END;
TRANSIT=OUT;


& Station receptrice simulant le second lien (2nd partie du 2nd chemin)
/STATION/
NAME=LIEN3;
TYPE= MULTIPLE(C);
SERVICE = BEGIN
        EXP(1./MU);
        App3OK := App3OK +1;
END;
CAPACITY = C;
& En cas de rejet, on compte le nombre d'appel bloque
REJECT = BEGIN
    App3Bloc := App3Bloc + 1;
    TRANSIT(OUT);
END;
TRANSIT=OUT;


/CONTROL/
TMAX = 10000;


/EXEC/
BEGIN
    FILASSIGN(courbe , "p1q3.data");
    OPEN(courbe);
    & Variation de la charge (RHO) de 10 a 70 (ERL) par pas de 10
    FOR RHO:=10 STEP 10 UNTIL ERL DO
    BEGIN
        LAMBDA := MU * RHO;
        & Variation de la capacite (C) pour posseder une charge normalisee (RHO) comprise entre 0.5 et 1
        FOR C := RHO STEP (RHO/2) UNTIL 2 * RHO DO
        BEGIN
            App1Bloc := 0;
            App1OK := 0;
            App2Bloc := 0;
            App2OK := 0;
            App3Bloc := 0;
            App3OK := 0;
            TOT := 0;
            TOTFAIL := 0;
            FOR I := 1 STEP 1 UNTIL NbSimu DO
            BEGIN
                SIMUL;
            END;
            App1Bloc := App1Bloc / NbSimu;
            App1OK := App1OK / NbSimu;
            App2Bloc := App2Bloc / NbSimu;
            App2OK := App2OK / NbSimu;
            App3Bloc := App3Bloc / NbSimu;
            App3OK := App3OK / NbSimu;
            WRITE(courbe, "  " , RHO , "  " , C , "  " , App1Bloc , "  " , App1OK , "  " , App1Bloc/(App1OK+App1Bloc));
            WRITE(courbe, " ",  App2Bloc , "  " , App2OK , "  " );
            IF((App2OK < 1) AND (App2Bloc <1)) THEN
                BEGIN
                        WRITE(courbe, "0");
                END
            ELSE
                BEGIN
                        WRITE(courbe, App2Bloc/(App2OK+App2Bloc));
                END;

            WRITE(courbe, " ",  App3Bloc , "  " , App3OK , "  " );

            IF((App3OK < 1) AND (App3Bloc <1)) THEN
                BEGIN
                        WRITE(courbe, "0");
                END
            ELSE
                BEGIN
                        WRITE(courbe, App3Bloc/(App3OK+App3Bloc));
                END;

            WRITELN(courbe, " ", TOT , " " , TOTFAIL , " " , (TOTFAIL / TOT) );
        END;
    END;
END;


/END/
